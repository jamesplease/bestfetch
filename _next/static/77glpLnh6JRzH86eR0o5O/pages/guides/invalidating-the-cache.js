(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{YFqc:function(e,t,n){e.exports=n("cTJO")},cTJO:function(e,t,n){"use strict";var o=n("lwsE"),s=n("W8MJ"),a=n("a1gu"),r=n("Nsbk"),l=n("7W2i"),c=n("TqRt"),i=n("284h");t.__esModule=!0,t.default=void 0;var u,h=i(n("q1tI")),p=n("QmWs"),f=n("g/15"),d=c(n("nOHt"));function m(e){return e&&"object"===typeof e?(0,f.formatWithValidation)(e):e}var v=new Map,y=window.IntersectionObserver,w={};function b(){return u||(y?u=new y((function(e){e.forEach((function(e){if(v.has(e.target)){var t=v.get(e.target);(e.isIntersecting||e.intersectionRatio>0)&&(u.unobserve(e.target),v.delete(e.target),t())}}))}),{rootMargin:"200px"}):void 0)}var g=function(e){function t(e){var n;return o(this,t),(n=a(this,r(t).call(this,e))).p=void 0,n.cleanUpListeners=function(){},n.formatUrls=function(e){var t=null,n=null,o=null;return function(s,a){if(o&&s===t&&a===n)return o;var r=e(s,a);return t=s,n=a,o=r,r}}((function(e,t){return{href:m(e),as:t?m(t):t}})),n.linkClicked=function(e){var t=e.currentTarget,o=t.nodeName,s=t.target;if("A"!==o||!(s&&"_self"!==s||e.metaKey||e.ctrlKey||e.shiftKey||e.nativeEvent&&2===e.nativeEvent.which)){var a=n.formatUrls(n.props.href,n.props.as),r=a.href,l=a.as;if(function(e){var t=(0,p.parse)(e,!1,!0),n=(0,p.parse)((0,f.getLocationOrigin)(),!1,!0);return!t.host||t.protocol===n.protocol&&t.host===n.host}(r)){var c=window.location.pathname;r=(0,p.resolve)(c,r),l=l?(0,p.resolve)(c,l):r,e.preventDefault();var i=n.props.scroll;null==i&&(i=l.indexOf("#")<0),d.default[n.props.replace?"replace":"push"](r,l,{shallow:n.props.shallow}).then((function(e){e&&i&&(window.scrollTo(0,0),document.body.focus())}))}}},n.p=!1!==e.prefetch,n}return l(t,e),s(t,[{key:"componentWillUnmount",value:function(){this.cleanUpListeners()}},{key:"getPaths",value:function(){var e=window.location.pathname,t=this.formatUrls(this.props.href,this.props.as),n=t.href,o=t.as,s=(0,p.resolve)(e,n);return[s,o?(0,p.resolve)(e,o):s]}},{key:"handleRef",value:function(e){var t=this;this.p&&y&&e&&e.tagName&&(this.cleanUpListeners(),w[this.getPaths().join("%")]||(this.cleanUpListeners=function(e,t){var n=b();return n?(n.observe(e),v.set(e,t),function(){try{n.unobserve(e)}catch(t){console.error(t)}v.delete(e)}):function(){}}(e,(function(){t.prefetch()}))))}},{key:"prefetch",value:function(e){if(this.p){var t=this.getPaths();d.default.prefetch(t[0],t[1],e).catch((function(e){0})),w[t.join("%")]=!0}}},{key:"render",value:function(){var e=this,t=this.props.children,n=this.formatUrls(this.props.href,this.props.as),o=n.href,s=n.as;"string"===typeof t&&(t=h.default.createElement("a",null,t));var a=h.Children.only(t),r={ref:function(t){e.handleRef(t),a&&"object"===typeof a&&a.ref&&("function"===typeof a.ref?a.ref(t):"object"===typeof a.ref&&(a.ref.current=t))},onMouseEnter:function(t){a.props&&"function"===typeof a.props.onMouseEnter&&a.props.onMouseEnter(t),e.prefetch({priority:!0})},onClick:function(t){a.props&&"function"===typeof a.props.onClick&&a.props.onClick(t),t.defaultPrevented||e.linkClicked(t)}};return!this.props.passHref&&("a"!==a.type||"href"in a.props)||(r.href=s||o),h.default.cloneElement(a,r)}}]),t}(h.Component);t.default=g},hdsl:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/guides/invalidating-the-cache",function(){return n("v/zC")}])},"v/zC":function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return r}));var o=n("q1tI"),s=n.n(o),a=(n("YFqc"),s.a.createElement);function r(){return a("div",{className:"page"},a("h1",null,"Invalidating the Cache"),a("p",null,"Out of the box, bestfech will never invalidate your cached responses. What this means is that a particular request will only ever hit the server ",a("b",null,"once"),", unless you configure bestfetch to behave differently."),a("p",null,"The reason this library works this way is because cache invalidation is a difficult problem, and each application has its own particular needs. It would be impossible for this library to include a default invalidation strategy and expect it to work for every use case in every app."),a("h2",null,"Defining Your Invalidation Strategy"),a("p",null,"You can configure an invalidation strategy that works for your application using the ",a("code",null,"responseCache.useCachedResponse()")," ","method."),a("p",null,"You only need to call this method a single time; typically before you start your application."),a("p",null,"To get started, import the ",a("code",null,"responseCache")," object:"),a("code",{className:"codeBlock"},"import { responseCache } from 'bestfetch';"),a("p",null,a("code",null,"responseCache.useCachedResponse()")," accepts a single argument: a function."),a("p",null,"It works like this: each time that a request is made that has a cached entry, the function that you pass will be called with a single argument: a ",a("code",null,"cacheObject")," (described below). Return ",a("code",null,"true")," ","from the function to use the cached response, or ",a("code",null,"false")," to immediately invalidate it."),a("code",{className:"codeBlock"},"import { responseCache } from 'bestfetch';\n\n// Call this method a single time: before your app mounts.\nresponseCache.useCachedResponse(() => /* return true or false */);"),a("h2",null,a("code",null,"cacheObject")),a("p",null,"The function that you pass to ",a("code",null,"useCachedResponse")," will be passed a single argument: ",a("code",null,"cacheObject"),". You can use this object to decide whether or not to use the cached reponse or not."),a("p",null,"A ",a("code",null,"cacheObject")," has the following shape:"),a("ul",null,a("li",null,a("code",null,"createdAt"),": A timestamp (in milliseconds) when the response was added to the cache."),a("li",null,a("code",null,"lastAccessedAt"),": A timecode (in milliseconds) when this response was last read from the cache."),a("li",null,a("code",null,"accessCount"),": How many times the response has been read from the cache."),a("li",null,a("code",null,"res"),": The cached response.")),a("h2",null,"Example: Invalidating Every Cached Entry"),a("p",null,"The simplest example to demonstrate how to use this function is to define a strategy that rejects ",a("i",null,"every")," cached entry."),a("code",{className:"codeBlock"},"import { responseCache } from 'bestfetch';\n\nresponseCache.useCachedResponse(() => false);"),a("p",null,"With this invalidation strategy in place, it is as if this library doesn't cache any responses at all. This isn't particularly useful, so let's look at more realistic examples."),a("h2",null,"Example: Invalidate After 10 Minutes"),a("p",null,"In the following example, we reject cached responses that are older than 10 minutes."),a("code",{className:"codeBlock"},"import { responseCache } from 'bestfetch';\n\n// 1000 = 1 second in milliseconds\n// * 60 = 1 minute\n// * 10 = 10 minutes\nconst TEN_MINUTES = 1000 * 60 * 10;\n\nresponseCache.useCachedResponse(cacheObject => {\n  const currentTimestamp = Date.now();\n  return currentTimestamp - cacheObject.createdAt <= TEN_MINUTES;\n});"),a("h2",null,"Example: Invalidate After 10 Times"),a("p",null,"In the following example, we only allow a cached response to be used up to 10 times."),a("code",{className:"codeBlock"},"import { responseCache } from 'bestfetch';\n\nresponseCache.useCachedResponse(cacheObject => {\n  return cacheObject.accessCount <= 10;\n});"))}}},[["hdsl",0,1,2]]]);