{"version":3,"file":"static/webpack/static/development/pages/guides/invalidating-the-cache.js.0c7f30cd30729e477535.hot-update.js","sources":["webpack:///./pages/guides/invalidating-the-cache.js"],"sourcesContent":["import Lowlight from 'react-lowlight';\n\nexport default function CachingResponses() {\n  return (\n    <div className=\"page\">\n      <h1>Invalidating the Cache</h1>\n      <p>\n        Out of the box, bestfech will never invalidate your cached responses.\n        What this means is that a particular request will only ever hit the\n        server <b>once</b>, unless you configure bestfetch to behave\n        differently.\n      </p>\n      <p>\n        The reason this library works this way is because cache invalidation is\n        a difficult problem, and each application has its own particular needs.\n        It would be impossible for this library to include a default\n        invalidation strategy and expect it to work for every use case in every\n        app.\n      </p>\n      <h2>Defining Your Invalidation Strategy</h2>\n      <p>\n        You can configure an invalidation strategy that works for your\n        application using the <code>responseCache.useCachedResponse()</code>{' '}\n        method.\n      </p>\n      <p>\n        You only need to call this method a single time; typically before you\n        start your application.\n      </p>\n      <p>\n        To get started, import the <code>responseCache</code> object:\n      </p>\n      <Lowlight\n        language=\"js\"\n        inline={false}\n        value={`import { responseCache } from 'bestfetch';`}\n      />\n      <p>\n        <code>responseCache.useCachedResponse()</code> accepts a single\n        argument: a function.\n      </p>\n      <p>\n        It works like this: each time that a request is made that has a cached\n        entry, the function that you pass will be called with a single argument:\n        a <code>cacheObject</code> (described below). Return <code>true</code>{' '}\n        from the function to use the cached response, or <code>false</code> to\n        immediately invalidate it.\n      </p>\n      <Lowlight\n        language=\"js\"\n        inline={false}\n        value={`import { responseCache } from 'bestfetch';\n\n// Call this method a single time: before your app mounts.\nresponseCache.useCachedResponse(() => /* return true or false */);`}\n      />\n      <h2>\n        <code>cacheObject</code>\n      </h2>\n      <p>\n        The function that you pass to <code>useCachedResponse</code> will be\n        passed a single argument: <code>cacheObject</code>. You can use this\n        object to decide whether or not to use the cached reponse or not.\n      </p>\n      <p>\n        A <code>cacheObject</code> has the following shape:\n      </p>\n      <ul>\n        <li>\n          <code>createdAt</code>: A timestamp (in milliseconds) when the\n          response was added to the cache.\n        </li>\n        <li>\n          <code>lastAccessedAt</code>: A timecode (in milliseconds) when this\n          response was last read from the cache.\n        </li>\n        <li>\n          <code>accessCount</code>: How many times the response has been read\n          from the cache.\n        </li>\n        <li>\n          <code>res</code>: The cached response.\n        </li>\n      </ul>\n      <h2>Example: Invalidating Every Cached Entry</h2>\n      <p>\n        The simplest example is to define a strategy that rejects <i>every</i>{' '}\n        cached entry.\n      </p>\n      <Lowlight\n        language=\"js\"\n        inline={false}\n        value={`import { responseCache } from 'bestfetch';\n\nresponseCache.useCachedResponse(() => false);`}\n      />\n      <code className=\"codeBlock\"></code>\n      <p>\n        With this invalidation strategy in place, it is as if this library\n        doesn't cache any responses at all. This isn't particularly useful, so\n        let's look at more realistic examples.\n      </p>\n      <h2>Example: Invalidate After 10 Minutes</h2>\n      <p>\n        In the following example, we reject cached responses that are older than\n        10 minutes.\n      </p>\n      <code className=\"codeBlock\">\n        {`import { responseCache } from 'bestfetch';\n\n// 1000 = 1 second in milliseconds\n// * 60 = 1 minute\n// * 10 = 10 minutes\nconst TEN_MINUTES = 1000 * 60 * 10;\n\nresponseCache.useCachedResponse(cacheObject => {\n  const currentTimestamp = Date.now();\n  return currentTimestamp - cacheObject.createdAt <= TEN_MINUTES;\n});`}\n      </code>\n      <h2>Example: Invalidate After 10 Times</h2>\n      <p>\n        In the following example, we only allow a cached response to be used up\n        to 10 times.\n      </p>\n      <code className=\"codeBlock\">\n        {`import { responseCache } from 'bestfetch';\n\nresponseCache.useCachedResponse(cacheObject => {\n  return cacheObject.accessCount <= 10;\n});`}\n      </code>\n    </div>\n  );\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;;;;A","sourceRoot":""}